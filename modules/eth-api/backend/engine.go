/*
 *   Copyright (c) 2024 Arcology Network

 *   This program is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 3 of the License, or
 *   (at your option) any later version.

 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.

 *   You should have received a copy of the GNU General Public License
 *   along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

package backend

import (
	"math/big"

	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/miner"

	"github.com/arcology-network/common-lib/types"
	mtypes "github.com/arcology-network/main/types"
	intf "github.com/arcology-network/streamer/interface"
	evmTypes "github.com/ethereum/go-ethereum/core/types"
)

// generateParams wraps various of settings for generating sealing task.
type generateParams struct {
	timestamp   uint64               // The timstamp for sealing task
	forceTime   bool                 // Flag whether the given timestamp is immutable or not
	parentHash  common.Hash          // Parent block hash, empty means the latest chain head
	coinbase    common.Address       // The fee recipient address for including transaction
	random      common.Hash          // The randomness generated by beacon chain, empty before the merge
	withdrawals evmTypes.Withdrawals // List of withdrawals to include in block.
	beaconRoot  *common.Hash         // The beacon root (cancun field).
	noTxs       bool                 // Flag whether an empty block without any transaction is expected

	txs      evmTypes.Transactions // Deposit transactions to include at the start of the block
	gasLimit *uint64               // Optional gas limit override
}

// getWorkReq represents a request for getting a new sealing work with provided parameters.
type getWorkReq struct {
	params *generateParams
	result chan *newPayloadResult // non-blocking channel
}

// newPayloadResult is the result of payload generation.
type newPayloadResult struct {
	err      error
	block    *evmTypes.Block
	fees     *big.Int                  // total block fees
	sidecars []*evmTypes.BlobTxSidecar // collected blobs of blob transactions
}

// getSealingBlock generates the sealing block based on the given parameters.
// The generation result will be passed back via the given channel no matter
// the generation itself succeeds or not.
func getSealingBlock(params *generateParams, rawTxs [][]byte, chainID uint64) *newPayloadResult {
	transactions := make([]*types.StandardTransaction, len(rawTxs))
	for i, tx := range params.txs {
		txhash := tx.Hash() //types.RlpHash(tx)
		transactions[i] = &types.StandardTransaction{
			TxHash:            txhash,
			NativeTransaction: tx,
			TxRawData:         append([]byte{types.TxType_Eth}, rawTxs[i]...),
			Source:            types.TxFrom_Local,
		}
	}
	request := &mtypes.OpRequest{
		BlockParam: &mtypes.BlockParams{
			Random:     params.random,
			BeaconRoot: params.beaconRoot,
			Times:      params.timestamp,
		},
		Withdrawals:  params.withdrawals,
		Transactions: transactions,
	}
	var response mtypes.QueryResult
	err := intf.Router.Call("pool", "ReceivedMessages", request, &response)
	if err != nil {
		return nil
	}
	result := response.Data.(*mtypes.BlockResult)
	return &newPayloadResult{
		block:    result.Block,
		fees:     result.Fees,
		sidecars: []*evmTypes.BlobTxSidecar{},
	}
}

// buildPayload builds the payload according to the provided parameters.
func buildPayload(args *miner.BuildPayloadArgs, rawTxs [][]byte, chainid uint64) (*Payload, error) {
	// Build the initial version with no transaction included. It should be fast
	// enough to run. The empty payload can at least make sure there is something
	// to deliver for not missing slot.
	// In OP-Stack, the "empty" block is constructed from provided txs only, i.e. no tx-pool usage.
	emptyParams := &generateParams{
		timestamp:   args.Timestamp,
		forceTime:   true,
		parentHash:  args.Parent,
		coinbase:    args.FeeRecipient,
		random:      args.Random,
		withdrawals: args.Withdrawals,
		beaconRoot:  args.BeaconRoot,
		noTxs:       false,
		txs:         args.Transactions,
		gasLimit:    args.GasLimit,
	}
	empty := getSealingBlock(emptyParams, rawTxs, chainid)
	if empty.err != nil {
		return nil, empty.err
	}

	// Construct a payload object for return.
	payload := newPayload(empty.block, args.Id())
	// if args.NoTxPool { // don't start the background payload updating job if there is no tx pool to pull from
	// make sure to make it appear as full, otherwise it will wait indefinitely for payload building to complete.
	payload.full = empty.block
	payload.fullFees = empty.fees

	return payload, nil
	// }

}
